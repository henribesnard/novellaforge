import streamlit as st
import os
from dotenv import load_dotenv
import base64
import time
import json
import glob
from utils.model_manager import ModelManager
from state import NovellaState
from novella_manager import NovellaForgeManager

# Chargement des variables d'environnement
load_dotenv()

# Configuration de base de Streamlit
st.set_page_config(
    page_title="NovellaForge - G√©n√©rateur de Novellas",
    page_icon="üìñ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Cr√©ation du dossier data s'il n'existe pas
os.makedirs("data", exist_ok=True)
os.makedirs("data/projects", exist_ok=True)

# Fonction pour lister tous les projets existants
def list_projects():
    projects = []
    for file_path in glob.glob("data/projects/*.json"):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                project_name = data.get("title", "Sans titre")
                project_id = os.path.basename(file_path).replace(".json", "")
                chapters = len(data.get("chapters", []))
                last_modified = os.path.getmtime(file_path)
                projects.append({
                    "id": project_id,
                    "name": project_name,
                    "chapters": chapters,
                    "last_modified": last_modified
                })
        except Exception as e:
            print(f"Erreur lors de la lecture du projet {file_path}: {e}")
    
    # Trier par date de modification (le plus r√©cent en premier)
    projects.sort(key=lambda x: x["last_modified"], reverse=True)
    return projects

# Fonction pour initialiser ou charger un gestionnaire de novella
@st.cache_resource
def get_manager(project_id=None):
    model_manager = ModelManager()
    state = NovellaState(project_id=project_id)
    return NovellaForgeManager(model_manager, state)

# Page d'accueil - S√©lection de projet
def home_page():
    st.title("üìö NovellaForge")
    st.markdown("### G√©n√©rateur de novellas bas√© sur l'IA")
    
    # Liste des projets existants
    projects = list_projects()
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.header("Projets existants")
        if not projects:
            st.info("Aucun projet existant. Cr√©ez votre premi√®re novella!")
        else:
            for i, project in enumerate(projects):
                with st.container(border=True):
                    col_a, col_b = st.columns([3, 1])
                    with col_a:
                        st.subheader(project["name"])
                        st.write(f"Chapitres: {project['chapters']}")
                        st.caption(f"Derni√®re modification: {time.ctime(project['last_modified'])}")
                    with col_b:
                        st.button("‚úèÔ∏è Ouvrir", key=f"open_{i}", on_click=open_project, args=(project["id"],))
                        if st.button("üóëÔ∏è Supprimer", key=f"delete_{i}"):
                            if st.session_state.get(f"confirm_delete_{i}", False):
                                delete_project(project["id"])
                                st.rerun()
                            else:
                                st.session_state[f"confirm_delete_{i}"] = True
                                st.warning("Confirmer la suppression?")
                                st.button("Annuler", key=f"cancel_delete_{i}", on_click=cancel_delete, args=(i,))
    
    with col2:
        st.header("Nouveau projet")
        with st.form("new_project_form"):
            title = st.text_input("Titre de la novella")
            genre = st.text_input("Genre", "Fantasy")
            submit = st.form_submit_button("üöÄ Cr√©er nouveau projet")
            
            if submit and title:
                # Cr√©er un nouvel identifiant unique pour le projet
                project_id = f"project_{int(time.time())}"
                
                # Initialiser un √©tat de novella vide avec les informations de base
                state = NovellaState(project_id=project_id)
                state.title = title
                state.concept = {"title": title, "genre": genre}
                state.save_to_file()
                
                # D√©finir le projet actif et naviguer vers l'application principale
                st.session_state["active_project"] = project_id
                st.session_state["view"] = "app"
                st.rerun()

# Fonction pour ouvrir un projet
def open_project(project_id):
    st.session_state["active_project"] = project_id
    st.session_state["view"] = "app"

# Fonction pour supprimer un projet
def delete_project(project_id):
    try:
        file_path = f"data/projects/{project_id}.json"
        if os.path.exists(file_path):
            os.remove(file_path)
            st.success("Projet supprim√© avec succ√®s")
    except Exception as e:
        st.error(f"Erreur lors de la suppression: {e}")

# Fonction pour annuler la suppression
def cancel_delete(index):
    if f"confirm_delete_{index}" in st.session_state:
        del st.session_state[f"confirm_delete_{index}"]

# Application principale - Gestion d'une novella
def app_page():
    # R√©cup√©rer l'ID du projet actif
    project_id = st.session_state.get("active_project")
    if not project_id:
        st.error("Aucun projet actif")
        return_to_home()
        return
    
    # Initialiser le gestionnaire avec le projet actif
    manager = get_manager(project_id)
    has_existing_novella = manager.state.load_from_file()
    
    if not has_existing_novella:
        st.error("Le projet n'a pas pu √™tre charg√©")
        return_to_home()
        return
    
    # Titre et pr√©sentation
    st.title(f"üìñ {manager.state.title}")
    
    # Barre lat√©rale pour informations g√©n√©rales
    with st.sidebar:
        st.button("üè† Retour √† l'accueil", on_click=return_to_home)
        
        st.subheader("NovellaForge")
        
        # Afficher le statut du mod√®le
        if manager.model_manager.primary_available:
            st.success("‚úì Mod√®le principal connect√©")
        elif manager.model_manager.fallback_available:
            st.warning("‚ö† Utilisation du mod√®le de secours")
        else:
            st.error("‚úó Aucun mod√®le LLM disponible")
        
        # Afficher les informations du projet
        st.subheader("Projet actuel")
        st.markdown(f"**Titre:** {manager.state.title}")
        st.markdown(f"**Chapitres:** {manager.state.current_chapter}")
    
    # Interface principale
    tabs = st.tabs(["üìù Concept", "üìÑ Chapitres", "üìä Analyse", "üì§ Export"])
    
    # Onglet Concept
    with tabs[0]:
        st.header("D√©finition du Concept")
        
        if manager.state.concept_details:
            # Permettre la modification du concept
            with st.expander("‚úèÔ∏è Modifier le concept", expanded=False):
                edit_concept(manager)
            
            # Afficher le concept d√©taill√©
            with st.expander("üìã D√©tails du concept", expanded=True):
                st.markdown(manager.state.concept_details)
                
            # Afficher les arcs narratifs
            with st.expander("üîÑ Arcs narratifs", expanded=False):
                st.markdown(manager.state.arcs)
        else:
            # Formulaire de cr√©ation de concept
            with st.form("concept_form"):
                create_concept_form(manager)
    
    # Onglet Chapitres
    with tabs[1]:
        st.header("√âcriture des Chapitres")
        
        # Afficher la chronologie
        with st.expander("‚è±Ô∏è Chronologie", expanded=False):
            st.markdown(manager.state.get_timeline_context())
        
        # Ajout d'un bouton externe pour la g√©n√©ration du chapitre suivant
        if manager.state.chapters:
            st.subheader("Action rapide")
            if st.button(f"üìù G√©n√©rer le chapitre {manager.state.current_chapter + 1}", 
                        use_container_width=True, 
                        key="quick_generate_button"):
                with st.spinner(f"G√©n√©ration du chapitre {manager.state.current_chapter + 1} en cours..."):
                    try:
                        # Utiliser les valeurs par d√©faut
                        result = manager.produce_chapter(
                            word_count=(1000, 1500),  # valeur par d√©faut : moyen
                            additional_context="",
                            avoid_repetition=True
                        )
                        st.success(f"‚úÖ Chapitre {manager.state.current_chapter} g√©n√©r√© avec succ√®s!")
                        st.rerun()
                    except Exception as e:
                        st.error(f"Erreur: {e}")
                        st.error("Essayez d'utiliser les options avanc√©es pour plus de contr√¥le.")
            st.markdown("---")
        
        # Formulaire pour la g√©n√©ration de chapitre avec options d√©taill√©es
        with st.expander("‚öôÔ∏è Options de g√©n√©ration avanc√©es", expanded=not manager.state.chapters):
            chapter_generation_form(manager)
        
        # Affichage et gestion des chapitres existants
        if not manager.state.chapters:
            st.info("‚ÑπÔ∏è Aucun chapitre n'a encore √©t√© g√©n√©r√©. Utilisez les options ci-dessus pour cr√©er le premier chapitre.")
        else:
            display_chapters(manager)
    
    # Onglet Analyse
    with tabs[2]:
        st.header("Analyse de la Novella")
        
        if not manager.state.chapters:
            st.warning("‚ö†Ô∏è G√©n√©rez d'abord des chapitres pour acc√©der √† l'analyse")
        else:
            display_analysis(manager)
    
    # Onglet Export
    with tabs[3]:
        st.header("Export de la Novella")
        
        if not manager.state.chapters:
            st.warning("‚ö†Ô∏è G√©n√©rez d'abord des chapitres pour pouvoir les exporter")
        else:
            export_options(manager)

# Fonction pour cr√©er/modifier le formulaire de concept
def create_concept_form(manager):
    # R√©cup√©rer les valeurs actuelles si elles existent
    concept = manager.state.concept or {}
    
    # Informations de base
    st.subheader("üìå Informations essentielles")
    col1, col2 = st.columns(2)
    with col1:
        title = st.text_input("Titre de la novella", value=concept.get("title", ""))
    with col2:
        genre = st.text_input("Genre principal", value=concept.get("genre", "Fantasy"))
    subgenres = st.text_input("Sous-genres (optionnel)", value=concept.get("subgenres", ""))
    
    # Contexte d√©taill√©
    st.subheader("üåç Contexte d√©taill√©")
    setting = st.text_area("Univers/Cadre", value=concept.get("setting", "Un monde m√©di√©val avec de la magie"))
    
    col1, col2 = st.columns(2)
    with col1:
        time_period = st.text_input("√âpoque/P√©riode", value=concept.get("time_period", ""))
    with col2:
        timeline_constraints = st.text_input("Contraintes temporelles", value=concept.get("timeline_constraints", ""))
    
    # Personnages
    st.subheader("üë• Personnages")
    protagonist = st.text_area("Protagoniste(s)", value=concept.get("protagonist", "Un jeune apprenti magicien"))
    antagonist = st.text_area("Antagoniste(s) ou conflit", value=concept.get("antagonist", "Un ancien mal qui s'√©veille"))
    supporting_characters = st.text_area("Personnages secondaires importants", value=concept.get("supporting_characters", ""))
    
    # √âl√©ments narratifs
    st.subheader("üìö √âl√©ments narratifs")
    main_plot = st.text_area("Intrigue principale", value=concept.get("main_plot", ""))
    subplots = st.text_area("Sous-intrigues potentielles", value=concept.get("subplots", ""))
    themes = st.text_area("Th√®mes √† explorer", value=concept.get("themes", ""))
    
    col1, col2 = st.columns(2)
    with col1:
        tone_options = ["Tr√®s sombre", "Sombre", "R√©aliste", "L√©ger", "Humoristique", "Satirique"]
        tone = st.select_slider("Ton g√©n√©ral", options=tone_options, value=concept.get("tone", "R√©aliste"))
    with col2:
        style_options = ["Tr√®s descriptif", "Descriptif", "√âquilibr√©", "Action", "Dialogue"]
        writing_style = st.select_slider("Style d'√©criture", options=style_options, value=concept.get("writing_style", "√âquilibr√©"))
    
    pov_options = ["Premi√®re personne", "Troisi√®me personne limit√©e", "Troisi√®me personne omnisciente"]
    narrative_pov = st.selectbox("Point de vue narratif", options=pov_options, index=pov_options.index(concept.get("narrative_pov", "Troisi√®me personne limit√©e")))
    
    # Contraintes additionnelles
    st.subheader("‚öôÔ∏è Contraintes additionnelles")
    special_requests = st.text_area("Requ√™tes sp√©ciales", value=concept.get("special_requests", ""))
    elements_to_avoid = st.text_area("√âl√©ments √† √©viter", value=concept.get("elements_to_avoid", ""))
    
    col1, col2 = st.columns(2)
    with col1:
        submit_button = st.form_submit_button("üöÄ G√©n√©rer le concept", use_container_width=True)
    with col2:
        reset_button = st.form_submit_button("üîÑ R√©initialiser le formulaire", use_container_width=True)
    
    if submit_button:
        if not title:
            st.error("Le titre est obligatoire")
        else:
            with st.spinner("G√©n√©ration du concept en cours..."):
                try:
                    # Cr√©ation d'un dictionnaire complet avec toutes les informations
                    user_input = {
                        "title": title,
                        "genre": genre,
                        "subgenres": subgenres,
                        "setting": setting,
                        "time_period": time_period,
                        "timeline_constraints": timeline_constraints,
                        "protagonist": protagonist,
                        "antagonist": antagonist,
                        "supporting_characters": supporting_characters,
                        "main_plot": main_plot,
                        "subplots": subplots,
                        "themes": themes,
                        "tone": tone,
                        "writing_style": writing_style,
                        "narrative_pov": narrative_pov,
                        "special_requests": special_requests,
                        "elements_to_avoid": elements_to_avoid
                    }
                    
                    # Initialisation ou mise √† jour de la novella
                    result = manager.initialize_novella(user_input)
                    st.success("‚úÖ Concept g√©n√©r√© avec succ√®s!")
                    st.rerun()
                except Exception as e:
                    st.error(f"Erreur: {e}")

# Fonction pour √©diter un concept existant
def edit_concept(manager):
    with st.form("edit_concept_form"):
        create_concept_form(manager)

# Formulaire pour la g√©n√©ration de chapitre
def chapter_generation_form(manager):
    chapter_length = st.select_slider(
        "Longueur du chapitre",
        options=["Court (500-800 mots)", "Moyen (1000-1500 mots)", "Long (1800-2500 mots)"],
        value="Moyen (1000-1500 mots)"
    )
    
    additional_context = st.text_area(
        "√âl√©ments contextuels √† int√©grer",
        placeholder="Ajoutez des √©l√©ments sp√©cifiques √† int√©grer dans ce chapitre...",
        help="Des d√©tails particuliers √† introduire dans ce chapitre: lieux, objets, √©v√©nements, etc."
    )
    
    col1, col2 = st.columns(2)
    with col1:
        avoid_repetition = st.checkbox("√âviter les r√©p√©titions d'intrigues", value=True)
    with col2:
        enforce_temporal = st.checkbox("Strict sur la coh√©rence temporelle", value=True)
    
    # Contraintes suppl√©mentaires pour ce chapitre
    additional_constraints = st.text_area(
        "Contraintes narratives sp√©cifiques",
        placeholder="Ex: focus sur un personnage particulier, sc√®ne d'action sp√©cifique...",
        help="Contraintes sp√©ciales pour ce chapitre uniquement"
    )
    
    # Utiliser un texte dynamique et une cl√© distincte pour le bouton de g√©n√©ration
    generate_text = "üìù G√©n√©rer le premier chapitre" if not manager.state.chapters else f"üìù G√©n√©rer le chapitre {manager.state.current_chapter + 1}"
    
    if st.button(generate_text, key="advanced_generate_button", use_container_width=True):
        with st.spinner(f"G√©n√©ration du chapitre {manager.state.current_chapter + 1} en cours..."):
            try:
                # Conversion de la s√©lection en mots
                if "Court" in chapter_length:
                    word_count = (500, 800)
                elif "Moyen" in chapter_length:
                    word_count = (1000, 1500)
                else:
                    word_count = (1800, 2500)
                
                # Construction du contexte additionnel
                full_context = additional_context
                if additional_constraints:
                    full_context += f"\nContraintes narratives:\n{additional_constraints}"
                
                # Ajout des param√®tres √† la fonction produce_chapter
                result = manager.produce_chapter(
                    word_count=word_count,
                    additional_context=full_context,
                    avoid_repetition=avoid_repetition
                )
                st.success(f"‚úÖ Chapitre {manager.state.current_chapter} g√©n√©r√© avec succ√®s!")
                # Force une actualisation compl√®te pour garantir l'affichage des nouveaux chapitres
                st.rerun()
            except Exception as e:
                st.error(f"Erreur: {e}")
                st.error("V√©rifiez les donn√©es fournies et r√©essayez.")

# Affichage des chapitres
def display_chapters(manager):
    st.subheader("Chapitres existants")
    
    # Onglets pour chaque chapitre
    chapter_tabs = st.tabs([f"Chapitre {ch['number']}" for ch in manager.state.chapters])
    
    for idx, (chapter, tab) in enumerate(zip(manager.state.chapters, chapter_tabs)):
        with tab:
            col1, col2 = st.columns([3, 1])
            
            with col1:
                # Afficher le contenu du chapitre
                st.markdown(chapter['content'])
            
            with col2:
                # Afficher le r√©sum√© et les m√©tadonn√©es
                with st.expander("üìã R√©sum√©", expanded=True):
                    chapter_summary = None
                    for summary in manager.state.summaries:
                        if summary["number"] == chapter["number"]:
                            chapter_summary = summary["summary"]
                            break
                    
                    if chapter_summary:
                        st.markdown(chapter_summary)
                    else:
                        st.info("Pas de r√©sum√© disponible")
                
                # Formulaire pour r√©√©crire le chapitre
                with st.expander("‚úèÔ∏è Modifier ce chapitre", expanded=False):
                    with st.form(f"edit_chapter_{chapter['number']}"):
                        st.subheader(f"√âditer le chapitre {chapter['number']}")
                        
                        edit_instructions = st.text_area(
                            "Instructions de r√©√©criture",
                            placeholder="Pr√©cisez les modifications souhait√©es...",
                            help="Ex: Ajouter plus de dialogue, changer le ton, d√©velopper un personnage...",
                            key=f"edit_instr_{chapter['number']}"
                        )
                        
                        col1, col2 = st.columns(2)
                        with col1:
                            rewrite_button = st.form_submit_button("‚úèÔ∏è R√©viser", use_container_width=True)
                        with col2:
                            regenerate_button = st.form_submit_button("üîÑ R√©g√©n√©rer", use_container_width=True)
                        
                        if rewrite_button and edit_instructions:
                            with st.spinner(f"R√©vision du chapitre {chapter['number']} en cours..."):
                                try:
                                    result = manager.rewrite_chapter(
                                        chapter_number=chapter['number'],
                                        instructions=edit_instructions,
                                        complete_rewrite=False
                                    )
                                    st.success(f"‚úÖ Chapitre {chapter['number']} r√©vis√©!")
                                    st.rerun()
                                except Exception as e:
                                    st.error(f"Erreur: {e}")
                        
                        if regenerate_button:
                            with st.spinner(f"R√©g√©n√©ration du chapitre {chapter['number']} en cours..."):
                                try:
                                    result = manager.rewrite_chapter(
                                        chapter_number=chapter['number'],
                                        instructions=edit_instructions,
                                        complete_rewrite=True
                                    )
                                    st.success(f"‚úÖ Chapitre {chapter['number']} r√©g√©n√©r√©!")
                                    st.rerun()
                                except Exception as e:
                                    st.error(f"Erreur: {e}")

# Analyse de la novella
def display_analysis(manager):
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üìà Progression narrative")
        
        # Afficher la chronologie compl√®te
        with st.expander("‚è±Ô∏è Chronologie d√©taill√©e", expanded=True):
            st.markdown(manager.state.get_timeline_context())
        
        # Afficher les √©l√©ments d'intrigue
        with st.expander("üîç √âl√©ments d'intrigue", expanded=True):
            if hasattr(manager.state, 'plot_elements') and manager.state.plot_elements:
                for element in manager.state.plot_elements:
                    st.markdown(f"**{element['name']}** (Ch. {element['introduced_in']} ‚Üí Ch. {element['last_mentioned_in']})")
                    st.markdown(f"_{element['description']}_")
                    st.markdown("---")
            else:
                st.info("Aucun √©l√©ment d'intrigue suivi pour le moment")
    
    with col2:
        st.subheader("üë• Personnages")
        
        # Simuler une analyse des personnages (√† impl√©menter r√©ellement)
        with st.expander("Analyse des personnages", expanded=True):
            st.info("Fonctionnalit√© d'analyse des personnages √† venir")
            st.markdown("Cette section permettra d'analyser l'√©volution des personnages au fil des chapitres.")
        
        # Simuler une analyse du ton et du style
        with st.expander("Ton et style", expanded=True):
            st.info("Fonctionnalit√© d'analyse du ton et du style √† venir")
            st.markdown("Cette section permettra d'analyser l'√©volution du ton et du style au fil des chapitres.")
    
    # Demander une analyse personnalis√©e
    st.subheader("üîé Analyse personnalis√©e")
    with st.form("custom_analysis"):
        analysis_type = st.selectbox(
            "Type d'analyse",
            ["Coh√©rence narrative", "√âvolution des personnages", "Progression temporelle", "Structure et rythme"]
        )
        
        # V√©rifier si des chapitres existent avant de cr√©er le multiselect
        chapter_options = [f"Chapitre {ch['number']}" for ch in manager.state.chapters]
        focus_chapters = st.multiselect(
            "Chapitres √† analyser",
            options=chapter_options,
            default=chapter_options
        )
        
        analyze_button = st.form_submit_button("üîç Analyser", use_container_width=True)
        
        if analyze_button:
            st.info("Fonctionnalit√© d'analyse personnalis√©e √† venir")
            st.markdown("Cette fonction permettra de g√©n√©rer des analyses sp√©cifiques selon vos besoins.")

# Options d'export
def export_options(manager):
    st.subheader("üì• Options d'export")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Export en Markdown
        st.markdown("### Markdown")
        if st.button("üìÑ Exporter en Markdown", key="export_md", use_container_width=True):
            try:
                md_path = manager.state.export_as_markdown()
                st.success(f"‚úÖ Novella export√©e: {md_path}")
                
                with open(md_path, "r", encoding="utf-8") as f:
                    md_content = f.read()
                    b64 = base64.b64encode(md_content.encode()).decode()
                    href = f'<a href="data:file/markdown;base64,{b64}" download="{manager.state.title.replace(" ", "_")}.md">üì• T√©l√©charger le fichier Markdown</a>'
                    st.markdown(href, unsafe_allow_html=True)
            except Exception as e:
                st.error(f"Erreur d'export: {e}")
    
    with col2:
        # Export en format texte brut
        st.markdown("### Texte brut")
        if st.button("üìÑ Exporter en texte brut", key="export_txt", use_container_width=True):
            try:
                txt_content = manager.state.get_all_chapters_as_markdown().replace("# ", "").replace("## ", "")
                b64 = base64.b64encode(txt_content.encode()).decode()
                href = f'<a href="data:file/txt;base64,{b64}" download="{manager.state.title.replace(" ", "_")}.txt">üì• T√©l√©charger le fichier texte</a>'
                st.markdown(href, unsafe_allow_html=True)
                st.success("‚úÖ Fichier texte pr√©par√© pour le t√©l√©chargement")
            except Exception as e:
                st.error(f"Erreur d'export: {e}")
    
    # Option d'export de la structure
    st.markdown("### Structure narrative")
    if st.button("üìã Exporter la structure narrative", key="export_structure", use_container_width=True):
        try:
            # Cr√©er un document de structure narrative
            structure = f"# Structure narrative de '{manager.state.title}'\n\n"
            
            # Ajouter le concept
            structure += "## Concept\n\n"
            structure += manager.state.concept_details + "\n\n"
            
            # Ajouter les arcs narratifs
            structure += "## Arcs narratifs\n\n"
            structure += manager.state.arcs + "\n\n"
            
            # Ajouter la chronologie
            structure += "## Chronologie\n\n"
            structure += manager.state.get_timeline_context() + "\n\n"
            
            # Ajouter les r√©sum√©s de chapitres
            structure += "## R√©sum√©s des chapitres\n\n"
            for summary in manager.state.summaries:
                structure += f"### Chapitre {summary['number']}\n\n"
                structure += summary['summary'] + "\n\n"
            
            # Cr√©er le lien de t√©l√©chargement
            b64 = base64.b64encode(structure.encode()).decode()
            href = f'<a href="data:file/markdown;base64,{b64}" download="Structure_{manager.state.title.replace(" ", "_")}.md">üì• T√©l√©charger la structure narrative</a>'
            st.markdown(href, unsafe_allow_html=True)
            st.success("‚úÖ Structure narrative pr√©par√©e pour le t√©l√©chargement")
        except Exception as e:
            st.error(f"Erreur d'export de la structure: {e}")

# Fonction pour retourner √† l'accueil
def return_to_home():
    st.session_state["view"] = "home"
    if "active_project" in st.session_state:
        del st.session_state["active_project"]

# Contr√¥le de navigation principal
if __name__ == "__main__":
    # D√©finir la vue par d√©faut si ce n'est pas d√©j√† fait
    if "view" not in st.session_state:
        st.session_state["view"] = "home"
    
    # Afficher la page appropri√©e
    if st.session_state["view"] == "home":
        home_page()
    else:
        app_page()
    
    # Pied de page
    st.markdown("---")
    st.markdown("NovellaForge ¬© 2025 - Un outil d'√©criture assist√©e par IA")