import streamlit as st
import os
from dotenv import load_dotenv
import base64
import time
from utils.model_manager import ModelManager
from state import NovellaState
from novella_manager import NovellaForgeManager

# Chargement des variables d'environnement
load_dotenv()

# Configuration de base de Streamlit
st.set_page_config(
    page_title="NovellaForge - G√©n√©rateur de Novellas",
    page_icon="üìñ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Titre et pr√©sentation
st.title("üìñ NovellaForge")
st.markdown("### Un g√©n√©rateur intelligent de novellas longues")

# Initialisation du gestionnaire
@st.cache_resource
def get_manager():
    model_manager = ModelManager()
    state = NovellaState()
    return NovellaForgeManager(model_manager, state)

manager = get_manager()

# V√©rifier si une novella existe d√©j√†
has_existing_novella = manager.state.load_from_file()

# Barre lat√©rale pour informations g√©n√©rales
with st.sidebar:
    st.subheader("NovellaForge")
    st.markdown("Cr√©ez des novellas captivantes avec l'aide de l'intelligence artificielle.")
    
    # Afficher le statut du mod√®le
    if manager.model_manager.primary_available:
        st.success("‚úì Mod√®le principal connect√©")
    elif manager.model_manager.fallback_available:
        st.warning("‚ö† Utilisation du mod√®le de secours")
    else:
        st.error("‚úó Aucun mod√®le LLM disponible")
    
    # Si une novella existe, afficher ses informations
    if has_existing_novella:
        st.subheader("Novella actuelle")
        st.markdown(f"**Titre:** {manager.state.title}")
        st.markdown(f"**Chapitres:** {manager.state.current_chapter}")
        
        if st.button("üóëÔ∏è R√©initialiser la novella", key="reset_sidebar"):
            if st.session_state.get("confirm_reset", False):
                manager.state = NovellaState()
                st.success("Novella r√©initialis√©e!")
                st.session_state.confirm_reset = False
                time.sleep(1)
                st.rerun()
            else:
                st.session_state.confirm_reset = True
                st.warning("√ätes-vous s√ªr? Toutes les donn√©es seront perdues. Cliquez √† nouveau pour confirmer.")
        
        if st.session_state.get("confirm_reset", False):
            if st.button("Annuler", key="cancel_reset"):
                st.session_state.confirm_reset = False
                st.rerun()

# Interface principale
tabs = st.tabs(["üìù Concept", "üìÑ Chapitres", "üìä Analyse", "üì§ Export"])

# Onglet Concept
with tabs[0]:
    st.header("D√©finition du Concept")
    
    if has_existing_novella and manager.state.concept:
        st.success(f"Concept existant: {manager.state.title}")
        
        # Afficher le concept d√©taill√©
        with st.expander("üìã D√©tails du concept", expanded=True):
            st.markdown(manager.state.concept_details)
            
        # Afficher les arcs narratifs
        with st.expander("üîÑ Arcs narratifs", expanded=False):
            st.markdown(manager.state.arcs)
            
        # Option pour r√©initialiser dans l'onglet concept
        if st.button("üóëÔ∏è R√©initialiser et cr√©er un nouveau concept", key="reset_concept"):
            if st.session_state.get("confirm_reset_concept", False):
                manager.state = NovellaState()
                st.success("Novella r√©initialis√©e!")
                st.session_state.confirm_reset_concept = False
                time.sleep(1)
                st.rerun()
            else:
                st.session_state.confirm_reset_concept = True
                st.warning("√ätes-vous s√ªr? Toutes les donn√©es seront perdues. Cliquez √† nouveau pour confirmer.")
        
        if st.session_state.get("confirm_reset_concept", False):
            if st.button("Annuler", key="cancel_reset_concept"):
                st.session_state.confirm_reset_concept = False
                st.rerun()
    else:
        # Formulaire de cr√©ation de concept
        with st.form("concept_form"):
            # Informations de base
            st.subheader("üìå Informations essentielles")
            col1, col2 = st.columns(2)
            with col1:
                title = st.text_input("Titre de la novella", "")
            with col2:
                genre = st.text_input("Genre principal", "Fantasy")
            subgenres = st.text_input("Sous-genres (optionnel)", "")
            
            # Contexte d√©taill√©
            st.subheader("üåç Contexte d√©taill√©")
            setting = st.text_area("Univers/Cadre", "Un monde m√©di√©val avec de la magie")
            
            col1, col2 = st.columns(2)
            with col1:
                time_period = st.text_input("√âpoque/P√©riode", "")
            with col2:
                timeline_constraints = st.text_input("Contraintes temporelles", "")
            
            # Personnages
            st.subheader("üë• Personnages")
            protagonist = st.text_area("Protagoniste(s)", "Un jeune apprenti magicien")
            antagonist = st.text_area("Antagoniste(s) ou conflit", "Un ancien mal qui s'√©veille")
            supporting_characters = st.text_area("Personnages secondaires importants", "")
            
            # √âl√©ments narratifs
            st.subheader("üìö √âl√©ments narratifs")
            main_plot = st.text_area("Intrigue principale", "")
            subplots = st.text_area("Sous-intrigues potentielles", "")
            themes = st.text_area("Th√®mes √† explorer", "")
            
            col1, col2 = st.columns(2)
            with col1:
                tone = st.select_slider("Ton g√©n√©ral", 
                                    options=["Tr√®s sombre", "Sombre", "R√©aliste", "L√©ger", "Humoristique", "Satirique"],
                                    value="R√©aliste")
            with col2:
                writing_style = st.select_slider("Style d'√©criture", 
                                           options=["Tr√®s descriptif", "Descriptif", "√âquilibr√©", "Action", "Dialogue"],
                                           value="√âquilibr√©")
            
            narrative_pov = st.selectbox("Point de vue narratif", 
                                       ["Premi√®re personne", "Troisi√®me personne limit√©e", "Troisi√®me personne omnisciente"])
            
            # Contraintes additionnelles
            st.subheader("‚öôÔ∏è Contraintes additionnelles")
            special_requests = st.text_area("Requ√™tes sp√©ciales", "")
            elements_to_avoid = st.text_area("√âl√©ments √† √©viter", "")
            
            col1, col2 = st.columns(2)
            with col1:
                submit_button = st.form_submit_button("üöÄ G√©n√©rer le concept", use_container_width=True)
            with col2:
                reset_button = st.form_submit_button("üîÑ R√©initialiser le formulaire", use_container_width=True)
            
            if submit_button:
                if not title:
                    st.error("Le titre est obligatoire")
                else:
                    with st.spinner("G√©n√©ration du concept en cours..."):
                        try:
                            # Cr√©ation d'un dictionnaire complet avec toutes les informations
                            user_input = {
                                "title": title,
                                "genre": genre,
                                "subgenres": subgenres,
                                "setting": setting,
                                "time_period": time_period,
                                "timeline_constraints": timeline_constraints,
                                "protagonist": protagonist,
                                "antagonist": antagonist,
                                "supporting_characters": supporting_characters,
                                "main_plot": main_plot,
                                "subplots": subplots,
                                "themes": themes,
                                "tone": tone,
                                "writing_style": writing_style,
                                "narrative_pov": narrative_pov,
                                "special_requests": special_requests,
                                "elements_to_avoid": elements_to_avoid
                            }
                            
                            # Initialisation de la novella
                            result = manager.initialize_novella(user_input)
                            st.success("‚úÖ Concept g√©n√©r√© avec succ√®s!")
                            st.rerun()
                        except Exception as e:
                            st.error(f"Erreur: {e}")

# Onglet Chapitres
with tabs[1]:
    st.header("√âcriture des Chapitres")
    
    if not has_existing_novella:
        st.warning("‚ö†Ô∏è Cr√©ez d'abord un concept dans l'onglet pr√©c√©dent")
    else:
        # Afficher la chronologie
        with st.expander("‚è±Ô∏è Chronologie", expanded=False):
            st.markdown(manager.state.get_timeline_context())
        
        # Ajout d'un bouton externe pour la g√©n√©ration du chapitre suivant
        # Ce bouton sera toujours visible et utilisera une cl√© unique
        if manager.state.chapters:
            st.subheader("Action rapide")
            if st.button(f"üìù G√©n√©rer le chapitre {manager.state.current_chapter + 1}", 
                        use_container_width=True, 
                        key="quick_generate_button"):
                with st.spinner(f"G√©n√©ration du chapitre {manager.state.current_chapter + 1} en cours..."):
                    try:
                        # Utiliser les valeurs par d√©faut
                        result = manager.produce_chapter(
                            word_count=(1000, 1500),  # valeur par d√©faut : moyen
                            additional_context="",
                            avoid_repetition=True
                        )
                        st.success(f"‚úÖ Chapitre {manager.state.current_chapter} g√©n√©r√© avec succ√®s!")
                        st.rerun()
                    except Exception as e:
                        st.error(f"Erreur: {e}")
            st.markdown("---")
        
        # Formulaire pour la g√©n√©ration de chapitre avec options d√©taill√©es
        with st.expander("‚öôÔ∏è Options de g√©n√©ration avanc√©es", expanded=not manager.state.chapters):
            chapter_length = st.select_slider(
                "Longueur du chapitre",
                options=["Court (500-800 mots)", "Moyen (1000-1500 mots)", "Long (1800-2500 mots)"],
                value="Moyen (1000-1500 mots)"
            )
            
            additional_context = st.text_area(
                "√âl√©ments contextuels √† int√©grer",
                placeholder="Ajoutez des √©l√©ments sp√©cifiques √† int√©grer dans ce chapitre...",
                help="Des d√©tails particuliers √† introduire dans ce chapitre: lieux, objets, √©v√©nements, etc."
            )
            
            col1, col2 = st.columns(2)
            with col1:
                avoid_repetition = st.checkbox("√âviter les r√©p√©titions d'intrigues", value=True)
            with col2:
                enforce_temporal = st.checkbox("Strict sur la coh√©rence temporelle", value=True)
                
            # Contraintes suppl√©mentaires pour ce chapitre
            additional_constraints = st.text_area(
                "Contraintes narratives sp√©cifiques",
                placeholder="Ex: focus sur un personnage particulier, sc√®ne d'action sp√©cifique...",
                help="Contraintes sp√©ciales pour ce chapitre uniquement"
            )
            
            # Utiliser un texte dynamique et une cl√© distincte pour le bouton de g√©n√©ration
            generate_text = "üìù G√©n√©rer le premier chapitre" if not manager.state.chapters else f"üìù G√©n√©rer le chapitre {manager.state.current_chapter + 1}"
            
            if st.button(generate_text, key="advanced_generate_button", use_container_width=True):
                with st.spinner(f"G√©n√©ration du chapitre {manager.state.current_chapter + 1} en cours..."):
                    try:
                        # Conversion de la s√©lection en mots
                        if "Court" in chapter_length:
                            word_count = (500, 800)
                        elif "Moyen" in chapter_length:
                            word_count = (1000, 1500)
                        else:
                            word_count = (1800, 2500)
                        
                        # Construction du contexte additionnel
                        full_context = additional_context
                        if additional_constraints:
                            full_context += f"\nContraintes narratives:\n{additional_constraints}"
                        
                        # Ajout des param√®tres √† la fonction produce_chapter
                        result = manager.produce_chapter(
                            word_count=word_count,
                            additional_context=full_context,
                            avoid_repetition=avoid_repetition
                        )
                        st.success(f"‚úÖ Chapitre {manager.state.current_chapter} g√©n√©r√© avec succ√®s!")
                        # Force une actualisation compl√®te pour garantir l'affichage des nouveaux chapitres
                        st.rerun()
                    except Exception as e:
                        st.error(f"Erreur: {e}")
        
        # Affichage et gestion des chapitres existants
        if not manager.state.chapters:
            st.info("‚ÑπÔ∏è Aucun chapitre n'a encore √©t√© g√©n√©r√©. Utilisez les options ci-dessus pour cr√©er le premier chapitre.")
        else:
            st.subheader("Chapitres existants")
            
            # Onglets pour chaque chapitre
            chapter_tabs = st.tabs([f"Chapitre {ch['number']}" for ch in manager.state.chapters])
            
            for idx, (chapter, tab) in enumerate(zip(manager.state.chapters, chapter_tabs)):
                with tab:
                    col1, col2 = st.columns([3, 1])
                    
                    with col1:
                        # Afficher le contenu du chapitre
                        st.markdown(chapter['content'])
                    
                    with col2:
                        # Afficher le r√©sum√© et les m√©tadonn√©es
                        with st.expander("üìã R√©sum√©", expanded=True):
                            chapter_summary = None
                            for summary in manager.state.summaries:
                                if summary["number"] == chapter["number"]:
                                    chapter_summary = summary["summary"]
                                    break
                            
                            if chapter_summary:
                                st.markdown(chapter_summary)
                            else:
                                st.info("Pas de r√©sum√© disponible")
                        
                        # Formulaire pour r√©√©crire le chapitre
                        with st.expander("‚úèÔ∏è Modifier ce chapitre", expanded=False):
                            with st.form(f"edit_chapter_{chapter['number']}"):
                                st.subheader(f"√âditer le chapitre {chapter['number']}")
                                
                                edit_instructions = st.text_area(
                                    "Instructions de r√©√©criture",
                                    placeholder="Pr√©cisez les modifications souhait√©es...",
                                    help="Ex: Ajouter plus de dialogue, changer le ton, d√©velopper un personnage...",
                                    key=f"edit_instr_{chapter['number']}"
                                )
                                
                                col1, col2 = st.columns(2)
                                with col1:
                                    rewrite_button = st.form_submit_button("‚úèÔ∏è R√©viser", use_container_width=True)
                                with col2:
                                    regenerate_button = st.form_submit_button("üîÑ R√©g√©n√©rer", use_container_width=True)
                                
                                if rewrite_button and edit_instructions:
                                    with st.spinner(f"R√©vision du chapitre {chapter['number']} en cours..."):
                                        try:
                                            result = manager.rewrite_chapter(
                                                chapter_number=chapter['number'],
                                                instructions=edit_instructions,
                                                complete_rewrite=False
                                            )
                                            st.success(f"‚úÖ Chapitre {chapter['number']} r√©vis√©!")
                                            st.rerun()
                                        except Exception as e:
                                            st.error(f"Erreur: {e}")
                                
                                if regenerate_button:
                                    with st.spinner(f"R√©g√©n√©ration du chapitre {chapter['number']} en cours..."):
                                        try:
                                            result = manager.rewrite_chapter(
                                                chapter_number=chapter['number'],
                                                instructions=edit_instructions,
                                                complete_rewrite=True
                                            )
                                            st.success(f"‚úÖ Chapitre {chapter['number']} r√©g√©n√©r√©!")
                                            st.rerun()
                                        except Exception as e:
                                            st.error(f"Erreur: {e}")

# Onglet Analyse
with tabs[2]:
    st.header("Analyse de la Novella")
    
    if not has_existing_novella or not manager.state.chapters:
        st.warning("‚ö†Ô∏è G√©n√©rez d'abord des chapitres pour acc√©der √† l'analyse")
    else:
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üìà Progression narrative")
            
            # Afficher la chronologie compl√®te
            with st.expander("‚è±Ô∏è Chronologie d√©taill√©e", expanded=True):
                st.markdown(manager.state.get_timeline_context())
            
            # Afficher les √©l√©ments d'intrigue
            with st.expander("üîç √âl√©ments d'intrigue", expanded=True):
                if hasattr(manager.state, 'plot_elements') and manager.state.plot_elements:
                    for element in manager.state.plot_elements:
                        st.markdown(f"**{element['name']}** (Ch. {element['introduced_in']} ‚Üí Ch. {element['last_mentioned_in']})")
                        st.markdown(f"_{element['description']}_")
                        st.markdown("---")
                else:
                    st.info("Aucun √©l√©ment d'intrigue suivi pour le moment")
        
        with col2:
            st.subheader("üë• Personnages")
            
            # Simuler une analyse des personnages (√† impl√©menter r√©ellement)
            with st.expander("Analyse des personnages", expanded=True):
                st.info("Fonctionnalit√© d'analyse des personnages √† venir")
                st.markdown("Cette section permettra d'analyser l'√©volution des personnages au fil des chapitres.")
            
            # Simuler une analyse du ton et du style
            with st.expander("Ton et style", expanded=True):
                st.info("Fonctionnalit√© d'analyse du ton et du style √† venir")
                st.markdown("Cette section permettra d'analyser l'√©volution du ton et du style au fil des chapitres.")
        
        # Demander une analyse personnalis√©e
        st.subheader("üîé Analyse personnalis√©e")
        with st.form("custom_analysis"):
            analysis_type = st.selectbox(
                "Type d'analyse",
                ["Coh√©rence narrative", "√âvolution des personnages", "Progression temporelle", "Structure et rythme"]
            )
            
            # V√©rifier si des chapitres existent avant de cr√©er le multiselect
            chapter_options = [f"Chapitre {ch['number']}" for ch in manager.state.chapters]
            focus_chapters = st.multiselect(
                "Chapitres √† analyser",
                options=chapter_options,
                default=chapter_options
            )
            
            analyze_button = st.form_submit_button("üîç Analyser", use_container_width=True)
            
            if analyze_button:
                st.info("Fonctionnalit√© d'analyse personnalis√©e √† venir")
                st.markdown("Cette fonction permettra de g√©n√©rer des analyses sp√©cifiques selon vos besoins.")

# Onglet Export
with tabs[3]:
    st.header("Export de la Novella")
    
    if not has_existing_novella or not manager.state.chapters:
        st.warning("‚ö†Ô∏è G√©n√©rez d'abord des chapitres pour pouvoir les exporter")
    else:
        st.subheader("üì• Options d'export")
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Export en Markdown
            st.markdown("### Markdown")
            if st.button("üìÑ Exporter en Markdown", key="export_md", use_container_width=True):
                try:
                    md_path = manager.state.export_as_markdown()
                    st.success(f"‚úÖ Novella export√©e: {md_path}")
                    
                    with open(md_path, "r", encoding="utf-8") as f:
                        md_content = f.read()
                        b64 = base64.b64encode(md_content.encode()).decode()
                        href = f'<a href="data:file/markdown;base64,{b64}" download="{manager.state.title.replace(" ", "_")}.md">üì• T√©l√©charger le fichier Markdown</a>'
                        st.markdown(href, unsafe_allow_html=True)
                except Exception as e:
                    st.error(f"Erreur d'export: {e}")
        
        with col2:
            # Export en format texte brut
            st.markdown("### Texte brut")
            if st.button("üìÑ Exporter en texte brut", key="export_txt", use_container_width=True):
                try:
                    txt_content = manager.state.get_all_chapters_as_markdown().replace("# ", "").replace("## ", "")
                    b64 = base64.b64encode(txt_content.encode()).decode()
                    href = f'<a href="data:file/txt;base64,{b64}" download="{manager.state.title.replace(" ", "_")}.txt">üì• T√©l√©charger le fichier texte</a>'
                    st.markdown(href, unsafe_allow_html=True)
                    st.success("‚úÖ Fichier texte pr√©par√© pour le t√©l√©chargement")
                except Exception as e:
                    st.error(f"Erreur d'export: {e}")
        
        # Option d'export de la structure
        st.markdown("### Structure narrative")
        if st.button("üìã Exporter la structure narrative", key="export_structure", use_container_width=True):
            try:
                # Cr√©er un document de structure narrative
                structure = f"# Structure narrative de '{manager.state.title}'\n\n"
                
                # Ajouter le concept
                structure += "## Concept\n\n"
                structure += manager.state.concept_details + "\n\n"
                
                # Ajouter les arcs narratifs
                structure += "## Arcs narratifs\n\n"
                structure += manager.state.arcs + "\n\n"
                
                # Ajouter la chronologie
                structure += "## Chronologie\n\n"
                structure += manager.state.get_timeline_context() + "\n\n"
                
                # Ajouter les r√©sum√©s de chapitres
                structure += "## R√©sum√©s des chapitres\n\n"
                for summary in manager.state.summaries:
                    structure += f"### Chapitre {summary['number']}\n\n"
                    structure += summary['summary'] + "\n\n"
                
                # Cr√©er le lien de t√©l√©chargement
                b64 = base64.b64encode(structure.encode()).decode()
                href = f'<a href="data:file/markdown;base64,{b64}" download="Structure_{manager.state.title.replace(" ", "_")}.md">üì• T√©l√©charger la structure narrative</a>'
                st.markdown(href, unsafe_allow_html=True)
                st.success("‚úÖ Structure narrative pr√©par√©e pour le t√©l√©chargement")
            except Exception as e:
                st.error(f"Erreur d'export de la structure: {e}")

# Pied de page
st.markdown("---")
st.markdown("NovellaForge ¬© 2025 - Un outil d'√©criture assist√©e par IA")